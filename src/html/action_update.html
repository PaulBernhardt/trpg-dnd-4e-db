<!--                                                                            ex: softtabstop=3 shiftwidth=3 tabstop=3 expandtab
  - action_update.html
  - Query online compendium and shows what can be downloaded / updated.
  -->
<div id='action_update' data-role='page'>
   <header role="navigation">
      <button class='i18n' onclick='od.gui.goto(od.action.list.url_current);'> action.list.link_text </button>
      <h1 class='i18n'>action.update.title</h1>
      <button class='i18n' onclick='od.gui.goto("about")'> action.about.link_text </button>
   </header>

   <style scoped>
      #act_download_tbl_list td:nth-child(4):hover, #act_download_tbl_list td:nth-child(5):hover {
         cursor: help; /* Indicate that more info is available */
         text-decoration: underline;
         color: red;
      }
      #act_download_tbl_list tr:hover {
         background-color: gold;
      }
   </style>

   <div>
      <p class='i18n'> action.update.paragraph.0 </p>
      <p class='i18n'> action.update.paragraph.1 </p>
      <p class='i18n hide' id='act_donwload_err_online'> action.update.err_online </p>
      <p class='i18n hide' id='act_donwload_err_nonie'> action.update.err_nonie </p>
      <p class='i18n hide' id='act_donwload_err_activex'> action.update.err_activex </p>
      <p>
         <button class='i18n' id='act_download_btn_get_catalog' onclick='od.action.update.get_catalog()'> action.update.btn_get_catalog </button>
         <button class='i18n' id='act_download_btn_all_list' onclick='od.action.update.list_all()'> action.update.btn_all_list </button>
         <button class='i18n' id='act_download_btn_update' onclick='od.action.update.update_all()'> action.update.btn_update_changed </button>
         <button class='i18n' id='act_download_btn_save' onclick='od.action.update.save()'> action.update.btn_save </button>
      </p>
   </div>
   <table id='act_download_tbl_list' class="fullw">
      <thead>
         <tr>
            <th class='i18n'> </th>
            <th class='i18n'> action.update.th_local </th>
            <th class='i18n'> action.update.th_remote </th>
            <th class='i18n'> action.update.th_new </th>
            <th class='i18n'> action.update.th_changed </th>
            <th class='i18n'> action.update.th_status </th>
            <th class='i18n'> action.update.th_commands </th>
         </tr>
      </thead>
      <tbody></tbody>
   </table>
   <!--fieldset id='act_download_lst_status'><legend class='i18n'>action.update.lst_thread</legend></fieldset-->
</div>
<script type='text/javascript'>'use strict';(function action_update_init(){
/*
 * Remote category commands by state:
 *  - local / absent: Reindex | Delete
 *  - unlisted: Check | Reindex | Delete
 *  - listing: (none)
 *  - listed: Recheck | Reindex | Delete | Update All | Update changed
 *  - downloading: Stop
 *  
 * Top buttons: List categories | Check all | Update changed | Stop all | Save | Reindex all
 *  
 * If any remote category has dirty data, save button may be available.
 * If any category is downloading, reindex/save is not available for all cat, since data is being updated.
 * A check will reload listing but will not reset dirty (copied to local) data.
 * Reindex and delete will erase any dirty data.  Both are non-stopable.
 *
 * Workflow:
 *   Load cat -> create remotes (local) -> Get cat -> Create / update remote state (unlisted or absent).
 *   List / Relist : reset ->  (listing) get_listing -> find_changed (listed)
 *   Download -> schedule_download -> get_data -> local.update, add to dirty
 */
od.action.update = {

   'initialize': function act_download_init () {
      _.hide( '#act_download_tbl_list, #act_download_btn_all_list, #act_download_btn_update, #act_download_btn_save');
      var online = location.protocol !== 'file:';
      var nonie = ! /\bMSIE (9|10)\.|\bTrident\b.+\brv:\d\d\./.test(navigator.userAgent);
      var activex = true;
      if ( ! nonie ) {
         try { // Active X disabled?
            activex = !!new ActiveXObject("htmlfile")
         } catch ( ignored ) {}
      }
      if ( online || nonie || ! activex ) {
         if ( nonie ) _.removeClass( '#act_donwload_err_nonie.hide' );
         if ( ! activex ) _.removeClass( '#act_donwload_err_activex.hide' );
         if ( online ) _.removeClass( '#act_donwload_err_online.hide' );
         _.hide( '#act_download_btn_get_catalog' );
         //alert( _.l( 'error.file_no_api' ) );
      }
      od.data.load_catalog(
         function loadCatalogOk(){
            od.data.get().forEach( function( c ){ od.updater.create( c.name ); } );
            od.action.update.refresh();
         },
         function loadCatalogFail(){
            od.action.update.refresh();
         }
      );
   },

   'setup': function act_download_setup () {
      od.action.update.refresh();
   },

   'cleanup': null,

   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

   'tr': {},

   'get_catalog' : function act_download_get_catalog () {
      od.updater.get_catalog( od.action.update.refresh );
   },

   'list_all' : function act_download_list_all () {
      od.updater.get().forEach( function act_download_list_all_each ( remote ) {
         var refresh = od.action.update.refresh_func( remote );
         if ( remote.state === 'unlisted' ) remote.get_listing( refresh, refresh );
      } );
   },

   'update_all' : function act_download_update_all () {
      od.updater.get().forEach( function act_download_update_all_each ( remote ) {
         if ( remote.state === 'listed' && ( remote.added.length || remote.changed.length ) ) {
            var refresh = od.action.update.refresh_func( remote );
            remote.update_changed( refresh, refresh );
         }
      } );
      _.hide( '#act_download_btn_update' );
   },

   'save' : function act_download_save () {
      var remotes = od.updater.get();
      var latch = new _.Latch( remotes.length+1 );
      remotes.forEach( function act_download_save_cat(e) {
         e.save( latch.count_down_function() );
      });
      latch.ondone = function act_download_save_done() {
         od.data.save_catalog();
         od.updater.dirty_catalog = false;
         _.hide( '#act_download_btn_save' );
      };
      latch.count_down();
   },

   lbl_count : function act_download_lbl_count ( list, label ) {
      return function act_download_lbl_count_click () {
         var remote = od.updater.get( this.parentNode.getAttribute('data-name') );
         var count = remote ? remote[list].length : 0;
         var message = _.l( 'action.update.' + label, null, count, _.escHtml( remote.title ) );
         if ( count <= 0 ) return alert( message );
         var win = open(), doc = win.document, listing = remote[list];
         doc.write( '<!DOCTYPE html><html style="background:#ED8"><h1>' + message + '</h1><p>' );
         remote.raw.forEach( function act_download_lbl_added_count_loop ( e ) {
            if ( listing.indexOf( e[0] ) >= 0 ) doc.write( '<b>' + e[1] + '</b><sub>, ' + e.slice(2).join(', ') + '</sub>' + '<br>' );
         } );
         // doc.write( '<button onclick="close()">' + _.l( 'action.update.btn_close' ) + '</button>' ); // Close button does not work in IE so don't border.
      }
   },

   'create_row' : function act_download_create_row( remote ) {
      var local = od.data.get( remote.name );
      var tr = _.create( 'tr', { 'data-name': remote.name } );
      tr.appendChild( _.create( 'th', remote.name ) );
      tr.appendChild( _.create( 'td', local ? local.count : '--' ) ); // 1: Local count
      tr.appendChild( _.create( 'td' ) ); // 2: Remote count
      tr.appendChild( _.create( 'td', { 'onclick': od.action.update.lbl_count( 'added'  , 'lbl_new_item' )   } ) ); // 3: Added count
      tr.appendChild( _.create( 'td', { 'onclick': od.action.update.lbl_count( 'changed', 'lbl_changed_item' ) } ) ); // 4: Changed count
      tr.appendChild( _.create( 'td' ) ); // 5: Actions
      _('#act_download_tbl_list tbody')[0].appendChild( tr );
      return this.tr[ remote.name ] = tr;
   },

   'create_button' : function act_download_create_button( command, remote, txt ) {
      var refreshRemote = od.action.update.refresh_func( remote );
      var param;
      switch ( command ) {
          case 'reindex' : 
             param = { 'text' : _.l( txt ), 'onclick' : function act_download_btn_reindex() {
                remote.reindex( refreshRemote, refreshRemote );
             }};
             break;
          case 'delete' :
             param = { 'text' : _.l( txt ), 'onclick' : function act_download_btn_reindex() {
                od.updater.delete( remote );
                od.action.update.refresh(); // Category can be deleted from remote, need full refresh to delete row
             }};
             break;
          case 'list' : 
             param = { 'text' : _.l( txt ), 'onclick' : function act_download_btn_list() {
                remote.get_listing( refreshRemote, refreshRemote );
                refreshRemote();
             }};
             break;
          case 'update_all':
             param = { 'text' : _.l( txt ), 'onclick' : function act_download_btn_update_all() {
                remote.update_all( refreshRemote, refreshRemote );
             }};
             break;
          case 'update':
             param = { 'text' : _.l( txt ), 'onclick' : function act_download_btn_update() {
                remote.update_changed( refreshRemote, refreshRemote );
             }};
             break;
      }
      return _.create( 'button', param );
   },

   'refresh_func' : function act_download_refresh_func ( remote_cat ) {
      return function act_download_refresh_func_callback () {
          od.action.update.refresh( remote_cat );
      };
    },

   'refresh' : function act_download_refresh ( remote_cat ) {
      var action = od.action.update;

      // Find whether there are unlisted (Check all), changed (Get all), Downloading & Dirty (Save all) items
      var unlisted = false, changed = false, downloading = false, dirty = od.updater.dirty_catalog;
      od.updater.get().forEach( function act_download_refresh_check( remote ) {
         switch ( remote.state ) {
            case "listing":
            case "absent" :
                break;
            case "local" :
                dirty = dirty || remote.dirty.length > 0; // May be dirty because of re-index
                break;
            case "unlisted" :
                unlisted = true;
                break;
            case "listed" :
                dirty = dirty || remote.dirty.length > 0;
                changed = changed || ( remote.added.length > 0 || remote.changed.length > 0 );
                break;
            case "downloading":
                downloading = true;
                break;
         }
      });

      // Update specified rows's state and commands
      function act_download_refresh_row ( remote ) {
         var tr = action.tr[ remote.name ];
         if ( tr === undefined ) tr = action.create_row( remote );
         var cells = _( tr, 'td' );
         var commands = cells[4];
         var local = od.data.get( remote.name );
         //var local = od.data.get( remote.name );
         //cells[1].textContent = local ? local.count : '--'; // Local count may change because of load failure or download update
         switch ( remote.state ) {
            case "listing":
            case "downloading":
               commands.textContent = remote.progress;
               break; // Please do not interrupt while working!
            case "absent" :
               cells[1].textContent =  cells[2].textContent =  cells[3].textContent = '--';
               commands.innerHTML = '';
               commands.appendChild( action.create_button( 'delete', remote, 'action.update.btn_delete' ) );
               if ( !remote.reindexed ) commands.appendChild( action.create_button( 'reindex', remote, 'action.update.btn_reindex' ) );
               break;
            case "local" :
               cells[1].textContent =  cells[2].textContent =  cells[3].textContent = '';
               commands.innerHTML = '';
               commands.appendChild( action.create_button( 'delete', remote, 'action.update.btn_delete' ) );
               if ( !remote.reindexed ) commands.appendChild( action.create_button( 'reindex', remote, 'action.update.btn_reindex' ) );
               break;
            case "unlisted" :
               cells[1].textContent =  cells[2].textContent =  cells[3].textContent = '??';
               commands.innerHTML = '';
               commands.appendChild( action.create_button( 'list', remote, 'action.update.btn_list' ) );
               if ( local ) {
                  commands.appendChild( action.create_button( 'delete', remote, 'action.update.btn_delete' ) );
                  if ( !remote.reindexed ) commands.appendChild( action.create_button( 'reindex', remote, 'action.update.btn_reindex' ) );
               }
               break;
            case "listed" :
               cells[1].textContent = remote.count;
               cells[2].textContent = remote.added.length;
               cells[3].textContent = remote.changed.length;
               commands.innerHTML = '';
               if ( remote.raw.length )
                  commands.appendChild( action.create_button( 'update_all', remote, 'action.update.btn_update_all' ) );
               if ( remote.added.length || remote.changed.length )
                  commands.appendChild( action.create_button( 'update', remote, 'action.update.btn_update_changed' ) );
               commands.appendChild( action.create_button( 'list', remote, 'action.update.btn_relist' ) );
               if ( local ) {
                  commands.appendChild( action.create_button( 'delete', remote, 'action.update.btn_delete' ) );
                  if ( !remote.reindexed ) commands.appendChild( action.create_button( 'reindex', remote, 'action.update.btn_reindex' ) );
               }
               break;
         }
      }

      if ( remote_cat !== undefined ) {
         act_download_refresh_row( remote_cat );
      } else {
         _.sort( od.updater.get(), 'name' ).forEach( act_download_refresh_row );
         // Remove rows that has been deleted
         Object.keys( action.tr ).forEach( function act_download_check_tr ( name ) {
            if ( od.updater.get( name ) === null ) {
               var row = action.tr[ name ];
               row.parentNode.removeChild( row );
               delete action.tr[ name ];
            }
         });
      }

      if ( changed ) {
         od.gui.set( '#act_download_btn_update', _.l( 'action.update.btn_update_changed' ) );
      }
      _.visible( '#act_download_btn_save', ( ! downloading ) && dirty );
      _.visible( '#act_download_btn_all_list', unlisted );
      _.visible( '#act_download_btn_update', changed );
      _.show('#act_download_tbl_list');
   }
};

})();</script>